'use strict';

/**
 * 设计方案就是采用中间件机制进行包装，检测如果是Buffer类型则不会进行封装处理。
 * 启动时读取前端的文件并输出，前端开发者可以自行决定如何使用。
 */

const fs = require('fs');

class tapi {

  constructor (options = {}) {

    this.methods = [
      'GET', 'OPTIONS', 'POST', 'PUT', 'DELETE'
    ];

    this.errinfo = {
      'OK'        : '请求成功',
      'ESYSBUSY'  : '系统繁忙，稍后再试',
      'ENOTFD'    : '请求资源没有发现',
      'EPERMDENY' : '不具备操作权限',
      'ENOTLOGIN' : '未登录',
      'EBADDAT'   : '数据格式错误',
      'ECOMMON'   : '请求出错，请稍后重试',
      'EFAILED'   : '请求失败，数据错误或服务繁忙',
      'EERROR'    : '系统执行错误',

      //通常是请求受到限制，比如调用接口超过最大次数
      'ELIMIT'    : '请求资源受限'
    };

    //捕获错误，把程序错误也包装在接口内，而不是返回500。
    this.catchError = false;

    //忽略二进制编码的字符串
    //this.ignoreBinary = true;

    this.rest = true;

    if (typeof options !== 'object') {
      options = {};
    }

    for (let k in options) {
      switch (k) {
        /* case 'ignoreBinary':
          this.ignoreBinary = options.ignoreBinary;
          break;
           */
        case 'catchError':
          this.catchError = options.catchError;
          break;
        
        //自定义错误状态码和错误信息
        case 'errCode':
          if (typeof options.errCode === 'object') {
            for (let c in options.errCode) {
              if (c.trim().length == 0) {
                continue;
              }

              this.errinfo[c] = options.errCode[c];
            }
          }
          break;

        case 'rest':
          this.rest = options.rest;
          break;

        default:;
      }

    }

  }

  mid () {
    let self = this

    if (this.rest) {
      if (this.catchError) {
        return async (c, next) => {
          c.apiset = (st, data = null) => {
            c.status(st)
            c.res.body = data
          }
    
          try {
            await next()
          } catch (err) {
            c.apiset(500, 'Server wrong.')
          }
        }
      }

      return async (c, next) => {

        c.apiset = (st, data = null) => {
          c.status(st)
          c.res.body = data
        }

        await next()

      }

    }

    return async (c, next) => {

      c.apiset = (st, data = null) => {
        c.res.body = self.ret(st, data)
      }

      if (!self.catchError) {
        await next()
      } else {
        try {
          await next()
        } catch (err) {
          c.apiset('EERROR')
        }
      }

    }
    //end return
  }

  einfo(e) {
    if (this.errinfo[e] === undefined) {
      return '未知错误';
    }
    return this.errinfo[e];
  }

  ret (status, data = null) {
    
    let r = {
      status : 'OK',
    }

    if (status === 0 || status == 'OK') {

      r.status = 'OK';
      if (data === null) {
        r.data = this.einfo(r.status);
      } else {
        r.data = data;
      }

    } else if (status === -1) {
      
      r.status = 'ECOMMON';
      r.data = this.einfo(r.status);

    } else {
      if (this.errinfo[status] === undefined) {
        status = 'ECOMMON';
      }
      
      r.status = status;

      r.data = data || this.einfo(r.status);

    }

    return r;

  }

  /**
   * 读取封装好的前端api文件
   */
  async getClientApp (objname = 'window', name = 'api') {
    let data = await new Promise((rv, rj) => {
      fs.readFile(`${__dirname}/apicall.js`, 'utf8', (err, data) => {
        if (err) {
          rj(err);
        } else {
          rv(data);
        }
      });

    });

    data = data.replace('__ERRCODE__', JSON.stringify(Object.keys(this.errinfo)));
    data = data.replace('__NAME__', name);
    data = data.replace('__MODE__', this.rest ? 'rest' : 'api');

    let filecontent = `;((exports)=>{\n${data}})(${objname});`;

    return filecontent;
  }
  
  async writeClientFile (filepath, objname = 'window', name = 'api') {
    
    let data = await this.getClientApp(objname || 'window', name || 'api');

    return new Promise((rv, rj) => {
      fs.writeFile(filepath, data, 'utf8', (err) => {
        if (err) {
          rj(err);
        } else {
          rv(true);
        }
      });

    });

  }


}

module.exports = tapi;
