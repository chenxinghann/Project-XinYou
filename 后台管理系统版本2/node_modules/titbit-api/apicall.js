'use strict';

/**
 * 需要考虑的需求是：大部分接口都是按照JSON传递的，上传文件以及获取文件通常不需要JSON格式。
 */

exports.__NAME__ = new function () {
  
  this._host = '';

  Object.defineProperty(this, 'host', {
    get : () => {
      return this._host;
    },
    set : (h) => {
      this._host = (h.length > 1 && [h.length-1] === '/') ? h.substring(0, h.length-1) : h;
    }
  })

  this.mode = '__MODE__';

  this.netError = null;

  this.errorHandle = null;

  this.failedHandle = null;

  this.errCode = __ERRCODE__;

  this.throwErrorCode = ['ENOTLOGIN', 'EPERMDENY', 'EERROR', 'ELIMIT'];

  this._fmtKVStr = (data) => {
    let tmp = '';
    for (let k in data) {
      tmp += `${k}=${encodeURIComponent(data[k])}&`;
    }

    return (tmp.length > 0 ? tmp.substring(0,tmp.length-1) : tmp);
  };

  this.bodyType = 'text';

  this.request = async (url, options = {}) => {
    let real_url = '';
    
    if (url.indexOf('http') === 0) {
      real_url = url;
    } else {
      real_url = `${this.host}${url[0] === '/' ? '' : '/'}${url}`;
    }

    if (options.mode === undefined) {
      options.mode = 'cors';
    }

    if (options.method === undefined) {
      options.method = 'GET';
    }

    if (options.headers === undefined) {
      options.headers = {};
    }

    if (options.method[0] === 'P') {
      if (options.body === undefined) {
        throw new Error(`method ${options.method} must with body.`);
      }
      let bodytype = typeof options.body;
      let ctype = null;
      if (bodytype === 'string' || bodytype === 'number') {
        ctype = 'text/plain';

      } else if (bodytype === 'object') {

        if (options.body.constructor.name !== 'FormData') {

          let bt = options.type || this.bodyType;

          if (bt === 'text') {
            ctype = 'text/plain';
            options.body = JSON.stringify(options.body);
          } else if (bt === 'form') {
            ctype = 'application/x-www-form-urlencoded';
            options.body = this._fmtKVStr(options.body);
          }
        }

      }

      if (ctype !== null && options.headers['content-type'] === undefined) {
        options.headers['content-type'] = ctype;
      }

    }

    if (options.query !== undefined && typeof options.query === 'object') {
      let q = real_url.indexOf('?') > 0 ? '&' : '?';
      real_url += `${q}${this._fmtKVStr(options.query)}`;
      delete options.query;
    }

    return fetch(real_url, options)
            .then(res => {
              if (!res.ok) {
                throw new Error(`${res.status}:${res.statusText}`);
              } else {
                if (options.dataType === undefined || options.dataType === 'json') {
                  return res.json();
                } else if (options.dataType === 'text') {
                  return res.text();
                } else {
                  return res.blob();
                }
              }
            })
            .then(d => {
              if (this.mode === 'rest') {
                return d;
              }

              if (typeof d === 'string') {
                return d;
              } else {
                if (d.status === 'OK') {
                  return d;
                } else {
                  if (this.throwErrorCode.indexOf(d.status) >= 0) {
                    throw new Error(`ECODE:${d.status}`);
                  }
                }
              }
            })
            .catch (err => {

              let thflag = true;

              let errmsg = err.message.toLowerCase();

              if (errmsg === 'failed to fetch' || errmsg.indexOf('networkerror') >= 0) {
                if (typeof this.netError === 'function') {
                  this.netError(err);
                  thflag = false;
                }
              } else if (err.message.indexOf('ECODE:') === 0) {
                if (typeof this.errorHandle === 'function') {
                  this.errorHandle(err.message.substring(6));
                  thflag = false;
                }
              } else {
                if (typeof this.failedHandle === 'function') {
                  this.failedHandle( parseInt(err.message.substring(0, 3)) );
                  thflag = false;
                }
              }

              if (thflag) {
                throw err;
              }

            });

  };

  this.get = async (url, options = {}) => {
    return this.request(url, options);
  };

  this.post = async (url, options = {}) => {
    options.method = 'POST';
    return this.request(url, options);
  };

  this.put = async (url, options = {}) => {
    options.method = 'PUT';
    return this.request(url, options);
  };

  this.delete = async (url, options = {}) => {
    options.method = 'DELETE';
    return this.request(url, options);
  };


};
